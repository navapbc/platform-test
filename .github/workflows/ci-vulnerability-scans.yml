# This workflow will scan the release versions of your Docker images, and standardize the results into a JSON file. This file
# can be used to create Github tickets and Slack alerts

name: Template Release Image Scans

on:
  schedule:
    - cron: '0 0 * * *'  # Run daily at midnight UTC
  pull_request:
    paths:
      # Handles when there are changes to the ignore files
      - .grype.yml        # Anchore ignore
      - .hadolint.yaml    # Hadolint ignore
      - .trivyignore.yaml # Trivy ignore
      - trivy.yaml        # Trivy config that points to the ignore file
      # Handles when there are changes to the actual workflows we use
      - .github/workflows/ci-vulnerability-scans.yml
      - .github/workflows/vulnerability-scans.yml
      - .github/actions/image-scan/action.yml
      # Add paths to monitor for changes that should trigger a scan
      ## Set for this example repo
      - app/Dockerfile
      - app/requirements.txt
      - app/.dockerignore
      - app-rails/Dockerfile
      - app-rails/Gemfile
      - app-rails/Gemfile.lock
      - app-rails/package.json
      - app-rails/package-lock.json
      - app-rails/.dockerignore
    # So we can run this workflow manually
    workflow_dispatch:

# These permissions are needed for opening Github tickets, remove comments if that functionality is enabled
# permissions:
#     contents: read
#     issues: write

jobs:
  matrix_image_scans:
    # Setting to new in case there's anything checking the existing vulnerability-scans.yml
    # This will be fixed before merging
    uses: ./.github/workflows/new-vulnerability-scans.yml
    strategy:
      # Lets all jobs run instead of cancelling if one of them fails
      fail-fast: false
      matrix:
        application:
          # Here you can define a list of applications that you want to scan. The format expected is as follows
          # - app_dir: The directory where the Makefile to run the command make release-build in
          #   app_name: A cleaned name to use for alerting purposes. An example could be something like "Flask Backend API"
          #   dockerfile: The path to and name of the Dockerfile to scan. An example would be something like api/prod.Dockerfile
          #   github_runner: The runner to use in the Github runner. The default is ubuntu-latest, but you can specify other runners if needed. For example, macos-latest or windows-latest.
          #   virtualize_arm: Boolean for whether to virtualize the ARM architecture for the scanner. This should be set to true if the Dockerfile uses an ARM based image.

          # Here is an example to scan the Temporal server image in a nested directory. The base image is ARM, so we need to virtualize
          # - app_dir: temporal-cluster
          #   app_name: "Temporal Server (frontend, history, matching, worker)"
          #   dockerfile: temporal-cluster/server.Dockerfile
          #   github_runner: ubuntu-latest
          #   virtualize_arm: "true"
          - app_dir: app
            app_name: "Example Python app"
            dockerfile: app/Dockerfile
            github_runner: ubuntu-latest
            virtualize_arm: "false"
          - app_dir: app-rails
            app_name: "Example rails app"
            dockerfile: app-rails/Dockerfile
            github_runner: ubuntu-latest
            virtualize_arm: "false"

    with:
      runner: ${{ matrix.application.runner }}
      virtualize_arm: ${{ matrix.application.virtualize_arm }}
      app_dir: ${{ matrix.application.app_dir }}
      dockerfile: ${{ matrix.application.dockerfile }}
      app_name: ${{ matrix.application.app_name }}
      # Alerting and ticket creation variables, disabled by default since not all alerting methods are used, 
      # or require setup before enabling
      alert_slack: "false"
      create_github_ticket: "false"
