name: Release image scans

on:
  workflow_call:
    inputs:
      runner:
        type: string
        # Defaults to using the x86 version of the Ubuntu runner
        default: ubuntu-latest
      # If you are using an x86 runner, and are building an ARM image, this input needs to be set to true.
      # The runner will run slow or fail trying to build ARM images. Set this to false if
      # the runner is an ARM based runner, ie - arm-linux-runner
      virtualize_arm:
        type: string
        default: "true"
      # The directory where the code is located in the repository. If it's not at the root, specify the path here. 
      # This will tell the workflow where the Makefile with the correct command to build the image is located
      app_dir:
        type: string
        default: ""
      # The path to the Dockerfile, including the Dockerfile name
      dockerfile:
        type: string
        default: ""
      # The name of the application, used for alerting. This should be something that makes it obvious what application is being scanned.
      app_name:
        type: string
        default: ""
      # Alerting or ticket creation enabled variables, disabled by default
      alert_slack:
        type: string
        default: "false"
      create_github_ticket:
        type: string
        default: "false"

# These permissions are needed for opening tickets
permissions:
    contents: read
    issues: write

env:
  # This is used to format the findings output. Options are
  #   - github_markdown (Will work with Github tickets, workflow outputs, etc. Might work for other Markdown viewers, but is untested)
  findings_format: github_markdown

jobs:
  release-image-scans:
    runs-on: ${{ inputs.runner }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Qemu for ARM virtualization image builds
        uses: docker/setup-qemu-action@v3.2.0
        if: ${{ inputs.virtualize_arm == 'true' }}

      - name: Build the release image
        env:
          APP_DIR: ${{ inputs.app_dir }}
          ECR_REGISTRY: image
          ECR_REPOSITORY: scans
          IMAGE_TAG: workflow
        run: |
          make release-build

      - name: Run image scanning suite
        uses: ./.github/actions/image-scan
        timeout-minutes: 10
        with:
          image-tag: image/scans:workflow
          dockerfile: ${{ inputs.dockerfile }}

      - name: Format findings to Github markdown and display in step summary
        if: ${{ always() }}
        id: formatted_findings
        env:
          APP_NAME: ${{ inputs.app_name }}
          DOCKERFILE: ${{ inputs.dockerfile }}
          FINDINGS_FORMAT: ${{ env.findings_format }}
        run: |
          python3 bin/image_scans/parse_findings.py
          cat github_markdown.md >> "$GITHUB_STEP_SUMMARY"
          echo "FINDINGS<<EOF" >> "$GITHUB_OUTPUT"
          cat markdown.md >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      # Github specific ticket creation step
      # This is disabled because it requires using Github for ticket management. If you plan on using this, it will create a ticket
      # in the repo this workflow runs from. If you would like it to automatically get added to a Github board, then you would need
      # to create a board workflow that takes any issues created in this repo with a specific label and adds them to that board.
      - name: Create Github ticket with findings
        if: ${{ failure() && inputs.create_github_ticket == 'true' }}
        id: create_github_ticket
        uses: JasonEtco/create-an-issue@v2.9.2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # These variables are used to sub in the template file
          APP_NAME: ${{ inputs.app_name }}
          IMAGE_FINDINGS: ${{ steps.formatted_findings.outputs.FINDINGS }}
          WORKFLOW_LINK: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          filename: .github/ISSUE_TEMPLATE/image-scan-findings.md
          # Allows us to reuse the same ticket instead of opening new ones each time
          update_existing: true
          # Only update open issues, otherwise we update closed ones
          search_existing: open

      # Slack specific alerting steps
      # This is disabled because to use this, you need to create a Slack webhook that is expecting this payload, and save
      # the webhook URL as a secret in your repository. This is not enabled by default because it requires additional setup
      - name: Decide what link to use for Slack alerting
        if: ${{ failure() && inputs.alert_slack == 'true' }}
        id: slack_link
        run: |
          SLACK_ALERT_LINK="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          if [ "${{ inputs.create_github_ticket }}" == "true" ]; then
            SLACK_ALERT_LINK="${{ steps.create_github_ticket.outputs.url }}"
          fi
          echo "SLACK_ALERT_LINK=$SLACK_ALERT_LINK" >> $GITHUB_OUTPUT

      - name: Alert Slack
        if: ${{ failure() && inputs.alert_slack == 'true' }}
        uses: slackapi/slack-github-action@v2.0.0
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.IMAGE_SCAN_NOTIFICATION_SLACK_URL }}
        with:
          webhook-type: webhook-trigger
          payload: |
            {
              "APPLICATION": "${{ inputs.app_name }}",
              "LINK": "${{ steps.slack_link.outputs.SLACK_ALERT_LINK }}"
            }
