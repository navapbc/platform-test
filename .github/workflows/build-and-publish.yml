name: Build and publish
run-name: Build and publish ${{ inputs.app_name }}:${{ inputs.ref }}

on:
  workflow_call:
    inputs:
      app_name:
        description: "name of application folder under infra directory"
        required: true
        type: string
      ref:
        description: The branch, tag or SHA to checkout. When checking out the repository that triggered a workflow, this defaults to the reference or SHA for that event. Otherwise, use branch or tag that triggered the workflow run.
        required: true
        type: string
    outputs:
      commit_hash:
        description: The SHA that was built
        value: ${{ jobs.get-commit-hash.outputs.commit_hash }}
  workflow_dispatch:
    inputs:
      app_name:
        description: "name of application folder under infra directory"
        required: true
        type: string
      ref:
        description: The branch, tag or SHA to checkout. When checking out the repository that triggered a workflow, this defaults to the reference or SHA for that event. Otherwise, use branch or tag that triggered the workflow run.
        required: true
        type: string

jobs:
  get-commit-hash:
    name: Get commit hash
    runs-on: ubuntu-latest

    outputs:
      commit_hash: ${{ steps.get-commit-hash.outputs.commit_hash }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}

      - name: Get commit hash
        id: get-commit-hash
        run: |
          # HEAD should be the same as inputs.ref since we checked out inputs.ref
          COMMIT_HASH=$(git rev-parse HEAD)
          echo "Commit hash: $COMMIT_HASH"
          echo "commit_hash=$COMMIT_HASH" >> "$GITHUB_OUTPUT"

  check-image-already-published:
    name: Check whether the image is already published
    runs-on: ubuntu-latest
    needs: get-commit-hash

    outputs:
      is_image_published: ${{ steps.check-image-published.outputs.is_image_published }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}

      - name: Set up Terraform
        uses: ./.github/actions/setup-terraform

      - name: Configure AWS credentials
        uses: ./.github/actions/configure-aws-credentials
        with:
          app_name: ${{ inputs.app_name }}
          environment: shared

      - name: Check if image is already published
        id: check-image-published
        run: |
          is_image_published=$(./bin/is-image-published "${{ inputs.app_name }}" "${{ needs.get-commit-hash.outputs.commit_hash }}")
          echo "Is image published: $is_image_published"
          echo "is_image_published=$is_image_published" >> "$GITHUB_OUTPUT"

  build-and-publish:
    runs-on: ubuntu-latest
    if: ${{ jobs.check-image-already-published.outputs.is_image_published == 'false' }}
    
    concurrency:
      group: build-${{ inputs.app_name }}-${{ github.ref }}
      cancel-in-progress: false

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}

      - id: build-release-candidate
        uses: ./.github/actions/build-release-candidate
        with:
          app_name: ${{ inputs.app_name }}

      - name: Restore cached Docker image
        uses: actions/cache/restore@v4
        with:
          path: /tmp/docker-image.tar
          key: ${{ steps.build-release-candidate.outputs.image_cache_key }}
          fail-on-cache-miss: true

      - name: Load cached Docker image
        run: |
          docker load < /tmp/docker-image.tar

      - name: Set up Terraform
        uses: ./.github/actions/setup-terraform

      - name: Configure AWS credentials
        uses: ./.github/actions/configure-aws-credentials
        with:
          app_name: ${{ inputs.app_name }}
          environment: shared

      - name: Publish release
        run: make APP_NAME=${{ inputs.app_name }} release-publish
